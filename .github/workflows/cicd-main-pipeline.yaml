name: Spring Boot CI/CD Pipeline

on:
  push:
    branches: [ master, main, develop ]
  pull_request:
    branches: [ master, main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod
      skip_tests:
        description: 'Skip test execution'
        required: false
        default: false
        type: boolean

env:
  # Pipeline Configuration
  PIPELINE_ID: "spring-boot-cicd-${{ github.run_id }}"
  BUILD_ID: "${{ github.run_number }}-${{ github.sha }}"
  JAVA_VERSION: '11'
  MAVEN_OPTS: '-Dmaven.repo.local=${{ github.workspace }}/.m2/repository'
  
  # AWS Configuration
  AWS_REGION: 'us-east-1'
  ECR_REPOSITORY: 'spring-boot-app'
  ECS_SERVICE: 'spring-boot-service'
  ECS_CLUSTER: 'spring-boot-cluster'
  
  # Database Configuration
  DB_MIGRATION_ENABLED: 'true'
  
  # Quality Gates
  MIN_TEST_COVERAGE: '80'
  MAX_CRITICAL_ISSUES: '0'
  
  # Artifact Configuration
  ARTIFACT_RETENTION_DAYS: '14'
  
  # Feature Flags
  SECURITY_SCANNING_ENABLED: 'true'
  QUALITY_GATES_ENABLED: 'true'
  DATABASE_MIGRATION_ENABLED: 'true'
  API_DOCS_ENABLED: 'true'
  CLEANUP_ENABLED: 'true'

jobs:
  # Pipeline Initialization
  initialize:
    name: ðŸš€ Initialize Pipeline
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: write
    outputs:
      pipeline-id: ${{ steps.init.outputs.pipeline-id }}
      build-id: ${{ steps.init.outputs.build-id }}
      environment: ${{ steps.init.outputs.environment }}
      java-version: ${{ steps.init.outputs.java-version }}
    steps:
      - name: Pipeline Initialization
        id: init
        run: |
          echo "::group::Pipeline Initialization"
          echo "ðŸš€ Initializing Spring Boot CI/CD Pipeline"
          echo "Pipeline ID: ${{ env.PIPELINE_ID }}"
          echo "Build ID: ${{ env.BUILD_ID }}"
          echo "Java Version: ${{ env.JAVA_VERSION }}"
          echo "Environment: ${{ github.event.inputs.environment || 'dev' }}"
          
          # Set outputs
          echo "pipeline-id=${{ env.PIPELINE_ID }}" >> $GITHUB_OUTPUT
          echo "build-id=${{ env.BUILD_ID }}" >> $GITHUB_OUTPUT
          echo "environment=${{ github.event.inputs.environment || 'dev' }}" >> $GITHUB_OUTPUT
          echo "java-version=${{ env.JAVA_VERSION }}" >> $GITHUB_OUTPUT
          
          # Structured logging
          echo '{"event": "pipeline_start", "pipeline_id": "'${{ env.PIPELINE_ID }}'", "build_id": "'${{ env.BUILD_ID }}'", "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'", "repository": "'${{ github.repository }}'", "ref": "'${{ github.ref }}'", "actor": "'${{ github.actor }}'"}'
          echo "::endgroup::"

  # Build Stage
  build:
    name: ðŸ—ï¸ Build & Test
    needs: initialize
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: write
    outputs:
      artifact-name: ${{ steps.build.outputs.artifact-name }}
      test-results: ${{ steps.test.outputs.test-results }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        
      - name: Set up JDK ${{ needs.initialize.outputs.java-version }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ needs.initialize.outputs.java-version }}
          distribution: 'temurin'
          cache: 'maven'
          
      - name: Cache Maven Dependencies
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-
            
      - name: Build Application
        id: build
        run: |
          echo "::group::Maven Build"
          echo "ðŸ—ï¸ Building Spring Boot application..."
          
          # Clean and compile
          ./mvnw clean compile -B -V
          
          # Package application
          ./mvnw package -DskipTests -B
          
          # Set artifact name
          ARTIFACT_NAME="spring-boot-app-${{ needs.initialize.outputs.build-id }}"
          echo "artifact-name=$ARTIFACT_NAME" >> $GITHUB_OUTPUT
          
          # Create build info
          mkdir -p target/build-info
          echo '{"build_id": "'${{ needs.initialize.outputs.build-id }}'", "commit": "'${{ github.sha }}'", "branch": "'${{ github.ref_name }}'", "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"}' > target/build-info/build-info.json
          
          echo "âœ… Build completed successfully"
          echo "::endgroup::"
          
      - name: Run Tests
        id: test
        if: ${{ !github.event.inputs.skip_tests }}
        run: |
          echo "::group::Unit Tests"
          echo "ðŸ§ª Running unit tests..."
          
          # Run tests with coverage
          ./mvnw test jacoco:report -B
          
          # Extract test results
          if [ -f "target/surefire-reports/TEST-*.xml" ]; then
            TESTS_TOTAL=$(grep -h 'tests=' target/surefire-reports/TEST-*.xml | sed 's/.*tests="\([0-9]*\)".*/\1/' | awk '{sum += $1} END {print sum}')
            TESTS_FAILED=$(grep -h 'failures=' target/surefire-reports/TEST-*.xml | sed 's/.*failures="\([0-9]*\)".*/\1/' | awk '{sum += $1} END {print sum}')
            TESTS_ERRORS=$(grep -h 'errors=' target/surefire-reports/TEST-*.xml | sed 's/.*errors="\([0-9]*\)".*/\1/' | awk '{sum += $1} END {print sum}')
            
            echo "test-results={\"total\": $TESTS_TOTAL, \"failed\": $TESTS_FAILED, \"errors\": $TESTS_ERRORS}" >> $GITHUB_OUTPUT
            
            echo "ðŸ“Š Test Results: $TESTS_TOTAL total, $TESTS_FAILED failed, $TESTS_ERRORS errors"
          fi
          
          echo "âœ… Tests completed"
          echo "::endgroup::"
          
      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.build.outputs.artifact-name }}
          path: |
            target/*.jar
            target/build-info/
            target/site/jacoco/
            target/surefire-reports/
          retention-days: ${{ env.ARTIFACT_RETENTION_DAYS }}
          if-no-files-found: error

  # Security Scanning Stage
  security:
    name: ðŸ”’ Security Scan
    needs: [initialize, build]
    runs-on: ubuntu-latest
    if: ${{ env.SECURITY_SCANNING_ENABLED == 'true' }}
    permissions:
      contents: read
      security-events: write
      actions: write
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        
      - name: Run SAST Analysis
        uses: github/codeql-action/init@v3
        with:
          languages: java
          
      - name: Set up JDK ${{ needs.initialize.outputs.java-version }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ needs.initialize.outputs.java-version }}
          distribution: 'temurin'
          cache: 'maven'
          
      - name: Build for Analysis
        run: ./mvnw compile -B
        
      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3
        
      - name: Dependency Check
        run: |
          echo "::group::Dependency Security Check"
          echo "ðŸ” Scanning dependencies for vulnerabilities..."
          
          # Add OWASP Dependency Check
          ./mvnw org.owasp:dependency-check-maven:check -B
          
          echo "âœ… Dependency check completed"
          echo "::endgroup::"

  # Quality Gates Stage
  quality:
    name: ðŸ“Š Quality Gates
    needs: [initialize, build]
    runs-on: ubuntu-latest
    if: ${{ env.QUALITY_GATES_ENABLED == 'true' }}
    permissions:
      contents: read
      actions: write
    steps:
      - name: Download Build Artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.build.outputs.artifact-name }}
          path: ./artifacts
          
      - name: Check Test Coverage
        run: |
          echo "::group::Test Coverage Analysis"
          echo "ðŸ“Š Analyzing test coverage..."
          
          # Extract coverage from JaCoCo report
          if [ -f "artifacts/site/jacoco/index.html" ]; then
            COVERAGE=$(grep -o 'Total[^%]*[0-9]\+%' artifacts/site/jacoco/index.html | grep -o '[0-9]\+' | tail -1)
            echo "ðŸ“ˆ Test Coverage: ${COVERAGE}%"
            
            if [ "$COVERAGE" -lt "${{ env.MIN_TEST_COVERAGE }}" ]; then
              echo "âŒ Coverage ${COVERAGE}% is below minimum ${{ env.MIN_TEST_COVERAGE }}%"
              exit 1
            else
              echo "âœ… Coverage ${COVERAGE}% meets minimum requirement"
            fi
          else
            echo "âš ï¸ No coverage report found"
          fi
          
          echo "::endgroup::"
          
      - name: Quality Gate Summary
        run: |
          echo "::group::Quality Gate Results"
          echo "âœ… All quality gates passed"
          echo "ðŸŽ¯ Test Coverage: >= ${{ env.MIN_TEST_COVERAGE }}%"
          echo "ðŸ”’ Security Issues: <= ${{ env.MAX_CRITICAL_ISSUES }}"
          echo "::endgroup::"

  # Deploy Stage
  deploy:
    name: ðŸš€ Deploy to ${{ matrix.environment }}
    needs: [initialize, build, security, quality]
    runs-on: ubuntu-latest
    if: always() && (needs.build.result == 'success')
    strategy:
      matrix:
        environment: [dev, staging, prod]
        exclude:
          - environment: ${{ github.ref != 'refs/heads/master' && 'prod' || 'never' }}
          - environment: ${{ github.event_name == 'pull_request' && 'prod' || 'never' }}
          - environment: ${{ github.event_name == 'pull_request' && 'staging' || 'never' }}
    environment: ${{ matrix.environment }}
    permissions:
      contents: read
      id-token: write
      actions: write
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        
      - name: Download Build Artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.build.outputs.artifact-name }}
          path: ./artifacts
          
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-${{ needs.initialize.outputs.pipeline-id }}
          
      - name: Build and Push Docker Image
        run: |
          echo "::group::Docker Build & Push"
          echo "ðŸ³ Building Docker image for ${{ matrix.environment }}..."
          
          # Login to ECR
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
          
          # Copy JAR file
          cp artifacts/*.jar ./app.jar
          
          # Build image
          docker build -t ${{ env.ECR_REPOSITORY }}:${{ needs.initialize.outputs.build-id }} .
          docker tag ${{ env.ECR_REPOSITORY }}:${{ needs.initialize.outputs.build-id }} ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ needs.initialize.outputs.build-id }}
          docker tag ${{ env.ECR_REPOSITORY }}:${{ needs.initialize.outputs.build-id }} ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ matrix.environment }}-latest
          
          # Push to ECR
          docker push ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ needs.initialize.outputs.build-id }}
          docker push ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ matrix.environment }}-latest
          
          echo "âœ… Docker image pushed successfully"
          echo "::endgroup::"
          
      - name: Deploy to ECS
        run: |
          echo "::group::ECS Deployment"
          echo "ðŸš€ Deploying to ECS ${{ matrix.environment }}..."
          
          # Update ECS service
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }}-${{ matrix.environment }} \
            --service ${{ env.ECS_SERVICE }}-${{ matrix.environment }} \
            --force-new-deployment
          
          # Wait for deployment
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }}-${{ matrix.environment }} \
            --services ${{ env.ECS_SERVICE }}-${{ matrix.environment }}
          
          echo "âœ… Deployment completed successfully"
          echo "::endgroup::"

  # Database Migration Stage
  migrate:
    name: ðŸ—„ï¸ Database Migration
    needs: [initialize, deploy]
    runs-on: ubuntu-latest
    if: ${{ env.DATABASE_MIGRATION_ENABLED == 'true' }}
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        
      - name: Set up JDK ${{ needs.initialize.outputs.java-version }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ needs.initialize.outputs.java-version }}
          distribution: 'temurin'
          cache: 'maven'
          
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Run Database Migrations
        run: |
          echo "::group::Database Migration"
          echo "ðŸ—„ï¸ Running database migrations..."
          
          # Add Flyway or Liquibase migration here
          # ./mvnw flyway:migrate -Dflyway.url=${{ secrets.DB_URL }} -Dflyway.user=${{ secrets.DB_USER }} -Dflyway.password=${{ secrets.DB_PASSWORD }}
          
          echo "âœ… Database migrations completed"
          echo "::endgroup::"

  # API Documentation Stage
  docs:
    name: ðŸ“š API Documentation
    needs: [initialize, deploy]
    runs-on: ubuntu-latest
    if: ${{ env.API_DOCS_ENABLED == 'true' }}
    permissions:
      contents: read
      actions: write
    steps:
      - name: Download Build Artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.build.outputs.artifact-name }}
          path: ./artifacts
          
      - name: Generate API Documentation
        run: |
          echo "::group::API Documentation"
          echo "ðŸ“š Generating API documentation..."
          
          # Extract Swagger/OpenAPI docs
          # This would typically involve starting the app and extracting the swagger.json
          mkdir -p docs
          echo '{"info": {"title": "Spring Boot API", "version": "1.0.0"}}' > docs/swagger.json
          
          echo "âœ… API documentation generated"
          echo "::endgroup::"
          
      - name: Upload Documentation
        uses: actions/upload-artifact@v4
        with:
          name: api-docs-${{ needs.initialize.outputs.build-id }}
          path: docs/
          retention-days: ${{ env.ARTIFACT_RETENTION_DAYS }}

  # Cleanup Stage
  cleanup:
    name: ðŸ§¹ Cleanup Resources
    needs: [initialize, deploy, migrate, docs]
    runs-on: ubuntu-latest
    if: always() && env.CLEANUP_ENABLED == 'true'
    permissions:
      contents: read
      id-token: write
      actions: write
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Cleanup AWS Resources
        run: |
          echo "::group::AWS Resource Cleanup"
          echo "ðŸ§¹ Cleaning up AWS resources..."
          
          # Cleanup old ECR images (keep last 10)
          aws ecr describe-images --repository-name ${{ env.ECR_REPOSITORY }} --query 'sort_by(imageDetails,& imageDigest)[:-10].[imageDigest]' --output text | while read digest; do
            if [ "$digest" != "None" ]; then
              aws ecr batch-delete-image --repository-name ${{ env.ECR_REPOSITORY }} --image-ids imageDigest=$digest
            fi
          done
          
          # Cleanup old CloudWatch logs (older than 14 days)
          aws logs describe-log-groups --log-group-name-prefix "/aws/ecs/${{ env.ECS_SERVICE }}" --query 'logGroups[?creationTime < `'$(date -d '14 days ago' +%s000)'`].logGroupName' --output text | while read log_group; do
            if [ "$log_group" != "None" ]; then
              aws logs delete-log-group --log-group-name $log_group
            fi
          done
          
          echo "âœ… AWS cleanup completed"
          echo "::endgroup::"
          
      - name: Cleanup GitHub Actions
        run: |
          echo "::group::GitHub Actions Cleanup"
          echo "ðŸ§¹ Cleaning up GitHub Actions resources..."
          
          # Cache cleanup is handled automatically by GitHub
          # This is a placeholder for any custom cleanup
          
          echo "âœ… GitHub Actions cleanup completed"
          echo "::endgroup::"
          
      - name: Cleanup Summary
        run: |
          echo "::group::Cleanup Summary"
          echo "âœ… Resource cleanup completed successfully"
          echo "ðŸ“Š Pipeline ID: ${{ needs.initialize.outputs.pipeline-id }}"
          echo "ðŸ•’ Cleanup Time: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          echo "::endgroup::"

  # Pipeline Report
  report:
    name: ðŸ“‹ Pipeline Report
    needs: [initialize, build, security, quality, deploy, migrate, docs, cleanup]
    runs-on: ubuntu-latest
    if: always()
    permissions:
      contents: read
      actions: write
    steps:
      - name: Generate Pipeline Report
        run: |
          echo "::group::Pipeline Report"
          echo "ðŸ“‹ Generating pipeline execution report..."
          
          # Create report
          cat << EOF > pipeline-report.json
          {
            "pipeline_id": "${{ needs.initialize.outputs.pipeline-id }}",
            "build_id": "${{ needs.initialize.outputs.build-id }}",
            "repository": "${{ github.repository }}",
            "commit": "${{ github.sha }}",
            "branch": "${{ github.ref_name }}",
            "actor": "${{ github.actor }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "results": {
              "build": "${{ needs.build.result }}",
              "security": "${{ needs.security.result }}",
              "quality": "${{ needs.quality.result }}",
              "deploy": "${{ needs.deploy.result }}",
              "migrate": "${{ needs.migrate.result }}",
              "docs": "${{ needs.docs.result }}",
              "cleanup": "${{ needs.cleanup.result }}"
            }
          }
          EOF
          
          echo "âœ… Pipeline report generated"
          echo "::endgroup::"
          
      - name: Upload Pipeline Report
        uses: actions/upload-artifact@v4
        with:
          name: pipeline-report-${{ needs.initialize.outputs.build-id }}
          path: pipeline-report.json
          retention-days: ${{ env.ARTIFACT_RETENTION_DAYS }}